<#
    //    Netapsys 2012/2013
    //    created by nan 15/10/2012 for Arquedi
    //    -> mise en place des features de base, +begin wcf
    //    used 24/04/2013 in Cristal 
    //    -> wcf capabilities
    //    remodified 24/06/2013 for Gepafo
    //    -> ajout des fichiers repo et factorisation de l'id.
    //    remasterized 1/07/2013 for Udssi
    //    -> multi edmx & config externalisé
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#>
 <#

    string configFilePath = Host.ResolvePath("Context.config.xml");       
    XDocument xdoc = XDocument.Load(configFilePath);

    List<XElement> usingsConfig = (from e in xdoc.Descendants("using") select e).ToList();
    List<XElement> modelsConfig = (from e in xdoc.Descendants("model") select e).ToList();
	
        var loader = new MetadataLoader(this);
        var region = new CodeRegion(this);
        Code = new CodeGenerationTools(this);
        EFTools = new MetadataTools(this);
	
        EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);
		

    foreach (XElement modelConfig in modelsConfig) {
        var inputFile = (modelConfig.Attribute("edmxfile").Value);
        var ItemCollection = loader.CreateEdmItemCollection(inputFile);

        ObjectNamespace = Code.VsNamespaceSuggestion();
        ModelNamespace = loader.GetModelNamespace(inputFile);
		
        EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
        if (container == null)
        {
            continue;
        }
		
            fileManager.StartNewFile(container.Name + ".cs");
#>
//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
<#
        foreach(XElement useme in usingsConfig){
#>
using <#=                useme.Attribute("namespace").Value #>;
<#
        }
#>
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Core.Objects;
using log4net;
<#
        if (container.FunctionImports.Any())
        {
#>
<#
        }
#>

<#

        if (!String.IsNullOrEmpty(ObjectNamespace))
        {
#>
namespace <#=                Code.EscapeNamespace(ObjectNamespace)#>
{
<#
            PushIndent(CodeRegion.GetIndent(1));
        }
#>
<#=            Accessibility.ForType(container)#> partial class <#=            Code.Escape(container)#> : DbContext, IDisposable
{

    /// <summary>
    /// Ctor
    /// </summary>
    public <#=Code.Escape(container)#>()
        : base("name=<#=container.Name#>")
    {

<#
        WriteLazyLoadingEnabled(container);
#>
    }

    /// <summary>
    /// Dtor
    /// </summary>
    ~<#=Code.Escape(container)#>(){
		Dispose();
    }

	/// <summary>
    /// Accéder à <see cref="T:System.Data.Entity.Core.Objects"/> sous-jacent au DbContext.
    /// </summary>
    /// <returns></returns>
	public ObjectContext ObjectContext
    {
		get
		{
			return (this as IObjectContextAdapter).ObjectContext;
		}
    }

	public bool SetChangeTrackerUse
    {
        set
        {
            this.Configuration.AutoDetectChangesEnabled = value;
        }
    }

    /// <summary>
    /// IDisposable impl
    /// </summary>
    /// <param name="disposing"></param>
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
    }

<#
        foreach (var entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
#>
    <#=                Accessibility.ForReadOnlyProperty(entitySet)#> DbSet<<#=                Code.Escape(entitySet.ElementType)#>> <#=                Code.Escape(entitySet)#> { get; set; }
<#
        }

        foreach (var edmFunction in container.FunctionImports)
        {
            WriteFunctionImport(edmFunction, false);
        }
#>


}
<#

        if (!String.IsNullOrEmpty(ObjectNamespace))
        {
            PopIndent();
#>
}
<#
        }
		}
        fileManager.Process();

#>
<#+
string ModelNamespace { get; set; }
string ObjectNamespace { get; set; }
CodeGenerationTools Code { get; set; }
MetadataTools EFTools { get; set; }

void WriteLazyLoadingEnabled(EntityContainer container)
{
   string lazyLoadingAttributeValue = null;
   var lazyLoadingAttributeName = MetadataConstants.EDM_ANNOTATION_09_02 + ":LazyLoadingEnabled";
   if(MetadataTools.TryGetStringMetadataPropertySetting(container, lazyLoadingAttributeName, out lazyLoadingAttributeValue))
   {
       bool isLazyLoading;
       if(bool.TryParse(lazyLoadingAttributeValue, out isLazyLoading) && !isLazyLoading)
       {
#>
        this.Configuration.LazyLoadingEnabled = false;
<#+
       }
   }
}


void WriteFunctionImport(EdmFunction edmFunction, bool includeMergeOption)
{
    var parameters = FunctionImportParameter.Create(edmFunction.Parameters, Code, EFTools);
    var paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
    var returnType = edmFunction.ReturnParameter == null ? null : EFTools.GetElementType(edmFunction.ReturnParameter.TypeUsage);
    var processedReturn = returnType == null ? "int" : "ObjectResult<" + MultiSchemaEscape(returnType) + ">";

    if (includeMergeOption)
    {
        paramList = Code.StringAfter(paramList, ", ") + "MergeOption mergeOption";
    }
#>

    <#=AccessibilityAndVirtual(Accessibility.ForMethod(edmFunction))#> <#=processedReturn#> <#=Code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#+
        if(returnType != null && (returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType ||
                                  returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.ComplexType))
        {
#>
        ((IObjectContextAdapter)this).ObjectContext.MetadataWorkspace.LoadFromAssembly(typeof(<#=MultiSchemaEscape(returnType)#>).Assembly);

<#+
        }

        foreach (var parameter in parameters.Where(p => p.NeedsLocalVariable))
        {
            var isNotNull = parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null";
            var notNullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", " + parameter.FunctionParameterName + ")";
            var nullInit = "new ObjectParameter(\"" + parameter.EsqlParameterName + "\", typeof(" + parameter.RawClrTypeName + "))";
#>
        var <#=parameter.LocalVariableName#> = <#=isNotNull#> ?
            <#=notNullInit#> :
            <#=nullInit#>;

<#+
        }

        var genericArg = returnType == null ? "" : "<" + MultiSchemaEscape(returnType) + ">";
        var callParams = Code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()));

        if (includeMergeOption)
        {
            callParams = ", mergeOption" + callParams;
        }
#>
        return ((IObjectContextAdapter)this).ObjectContext.ExecuteFunction<#=genericArg#>("<#=edmFunction.Name#>"<#=callParams#>);
    }
<#+
    if(!includeMergeOption && returnType != null && returnType.EdmType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
    {
        WriteFunctionImport(edmFunction, true);
    }
}

string AccessibilityAndVirtual(string accessibility)
{
    return accessibility + (accessibility != "private" ? " virtual" : "");
}

string MultiSchemaEscape(TypeUsage usage)
{
    var type = usage.EdmType as StructuralType;
    return type != null && type.NamespaceName != ModelNamespace ?
        Code.CreateFullName(Code.EscapeNamespace(type.NamespaceName), Code.Escape(type)) :
        Code.Escape(usage);
}

#>